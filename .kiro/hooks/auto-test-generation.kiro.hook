{
  "enabled": true,
  "name": "Auto Test Generation on Save",
  "description": "Automatically generates or updates unit and integration tests using PHPUnit/Pest best practices whenever PHP files are saved. Covers edge cases, validation rules, Filament form submissions, table actions, and uses MCP to run existing tests and intelligently fix failures.",
  "version": "1",
  "when": {
    "type": "fileEdited",
    "patterns": [
      "app/**/*.php",
      "app-modules/**/*.php"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "A PHP file has been modified. Your task is to generate or update comprehensive tests for this file following these requirements:\n\n## Test Generation Requirements\n\n1. **Analyze the modified file** to understand:\n   - Class type (Model, Resource, Action, Service, Controller, etc.)\n   - Public methods and their responsibilities\n   - Validation rules and business logic\n   - Filament-specific interactions (forms, tables, actions, relation managers)\n   - Dependencies and relationships\n\n2. **Generate/Update Pest tests** that cover:\n   - **Unit tests** for isolated logic, edge cases, and validation\n   - **Integration tests** for Filament interactions:\n     - Form submissions with valid/invalid data\n     - Table actions (view, edit, delete, bulk actions)\n     - Relation manager operations\n     - Authorization checks (canView, canCreate, canEdit, canDelete)\n     - Search, filter, and sort functionality\n   - **Edge cases**: null values, empty strings, boundary conditions, invalid types\n   - **Error handling**: exceptions, validation failures, authorization denials\n\n3. **Follow PHPUnit/Pest best practices**:\n   - Use descriptive test names: `it('can create customer with valid data')`\n   - Leverage factories for test data\n   - Use `livewire()` helper for Filament component testing\n   - Assert database state, notifications, redirects, and form errors\n   - Test both happy paths and failure scenarios\n   - Keep tests focused and independent\n\n4. **Use MCP to run tests**:\n   - Execute existing tests related to the modified file\n   - Analyze any failures and fix them intelligently\n   - Ensure new tests pass before completing\n   - Run `composer test` to verify overall suite health\n\n5. **Test file organization**:\n   - Place tests in `tests/Feature/` or `tests/Unit/` matching the source structure\n   - Name test files as `[ClassName]Test.php`\n   - Group related tests using `describe()` blocks\n\n6. **Filament-specific patterns**:\n   ```php\n   it('can list records', function () {\n       $records = Model::factory()->count(10)->create();\n       livewire(ListResource::class)\n           ->assertCanSeeTableRecords($records);\n   });\n\n   it('can create record', function () {\n       livewire(CreateResource::class)\n           ->fillForm(['name' => 'Test'])\n           ->call('create')\n           ->assertHasNoFormErrors();\n   });\n\n   it('can search table', function () {\n       livewire(ListResource::class)\n           ->searchTable('query')\n           ->assertCanSeeTableRecords([...]);\n   });\n   ```\n\n7. **Coverage goals**:\n   - Aim for 80%+ code coverage\n   - Cover all public methods\n   - Test authorization boundaries\n   - Validate all form fields and rules\n\n## Output Format\n\nProvide:\n1. Path to the test file (create if doesn't exist)\n2. Complete test code following Pest syntax\n3. Summary of what's being tested\n4. Any test execution results from MCP\n5. Recommendations for additional test scenarios if needed\n\nModified file: {file_path}\nFile contents: {file_contents}"
  },
  "workspaceFolderName": "crm",
  "shortName": "auto-test-generation"
}